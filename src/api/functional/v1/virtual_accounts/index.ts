/**
 * @packageDocumentation
 * @module api.functional.v1.virtual_accounts
 * @nestia Generated by Nestia - https://github.com/samchon/nestia 
 */
//================================================================
import { Fetcher } from "@nestia/fetcher";
import type { IConnection, Primitive } from "@nestia/fetcher";
import typia from "typia";

import { NestiaSimulator } from "./../../../utils/NestiaSimulator";
import type { ITossVirtualAccountPayment } from "./../../../structures/ITossVirtualAccountPayment";

/**
 * 가상 계좌로 결제 신청하기.
 * 
 * `virtual_accounts.store` 는 고객이 결제 수단을 가상 계좌로 선택하는 경우에 호출되는
 * API 함수이다. 물론 고객이 이처럼 가상 계좌를 선택한 경우, 고객이 지정된 계좌에 돈을
 * 입금하기 전까지는 결제가 마무리된 것이 아니기에, {@link ITossPayment.status} 값은
 * `WAITING_FOR_DEPOSIT` 이 된다.
 * 
 * 참고로 `virtual_accounts.store` 는 클라이언트 어플리케이션이 토스 페이먼츠가
 * 자체적으로 제공하는 결제 창을 사용하는 경우, 귀하의 백엔드 서버가 이를 실 서비스에서
 * 호출하는 일은 없을 것이다. 다만, 고객이 가상 계좌로 결제를 진행하는 상황을
 * 시뮬레이션하기 위하여, 테스트 자동화 프로그램 수준에서 사용될 수는 있다.
 * 
 * 그리고 `virtual_accounts.store` 이후에 고객이 지정된 계좌에 금액을 입금하거든, 토스
 * 페이먼츠 서버로부터 웹훅 이벤트가 발생되어 귀하의 백엔드 서버로 전송된다. 만약 연동
 * 대상 토스 페이먼츠 서버가 실제가 아닌 `fake-toss-payments-server` 라면,
 * {@link internal.virtual_accounts.deposit} 를 호출하여, 고객이 가상 계좌에 입금하는
 * 상황을 시뮬레이션 할 수 있다.
 * 
 * @param input 가상 결제 신청 정보.
 * @returns 가상 계좌 결제 정보
 * 
 * @author Jeongho Nam - https://github.com/samchon
 * 
 * @controller FakeTossVirtualAccountsController.store()
 * @path POST /v1/virtual-accounts
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function store(
    connection: IConnection,
    input: store.Input,
): Promise<store.Output> {
    return !!(connection.simulate ?? (connection as any).random)
        ? store.simulate(
              connection,
              input,
          )
        : Fetcher.fetch(
              connection,
              store.ENCRYPTED,
              store.METHOD,
              store.path(),
              input,
          );
}
export namespace store {
    export type Input = Primitive<ITossVirtualAccountPayment.IStore>;
    export type Output = Primitive<ITossVirtualAccountPayment>;

    export const METHOD = "POST" as const;
    export const PATH: string = "/v1/virtual-accounts";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export const path = (): string => {
        return `/v1/virtual-accounts`;
    }
    export const random = (g?: Partial<typia.IRandomGenerator>): Output =>
        typia.random<Output>(g);
    export const simulate = async (
        connection: IConnection,
        input: store.Input,
    ): Promise<Output> => {
        const assert = NestiaSimulator.assert({
            method: METHOD,
            host: connection.host,
            path: path()
        });
        assert.body(() => typia.assert(input));
        return random(
            typeof (connection.simulate ?? (connection as any).random) === 'object'
            && (connection.simulate ?? (connection as any).random) !== null
                ? (connection.simulate ?? (connection as any).random)
                : undefined
        );
    }
}